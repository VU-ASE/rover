/* tslint:disable */
/* eslint-disable */
/**
 * roverd REST API
 * API exposed from each rover to allow process, service, source and file management
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BuildError
 */
export interface BuildError {
    /**
     * The build log (one log line per item)
     * @type {Array<string>}
     * @memberof BuildError
     */
    'build_log': Array<string>;
}
/**
 * The status of the roverd process
 * @export
 * @enum {string}
 */

export const DaemonStatus = {
    Operational: 'operational',
    Recoverable: 'recoverable',
    Unrecoverable: 'unrecoverable'
} as const;

export type DaemonStatus = typeof DaemonStatus[keyof typeof DaemonStatus];


/**
 * 
 * @export
 * @interface FetchPost200Response
 */
export interface FetchPost200Response {
    /**
     * 
     * @type {FullyQualifiedService}
     * @memberof FetchPost200Response
     */
    'fq': FullyQualifiedService;
    /**
     * Whether the pipeline was invalidated by this service upload
     * @type {boolean}
     * @memberof FetchPost200Response
     */
    'invalidated_pipeline': boolean;
}
/**
 * 
 * @export
 * @interface FetchPostRequest
 */
export interface FetchPostRequest {
    /**
     * Download URL of the service to be downloaded, must include scheme
     * @type {string}
     * @memberof FetchPostRequest
     */
    'url': string;
}
/**
 * FullyQualifiedService
 * @export
 * @interface FullyQualifiedService
 */
export interface FullyQualifiedService {
    /**
     * The author of the service
     * @type {string}
     * @memberof FullyQualifiedService
     */
    'author': string;
    /**
     * The name of the service
     * @type {string}
     * @memberof FullyQualifiedService
     */
    'name': string;
    /**
     * The version of the service
     * @type {string}
     * @memberof FullyQualifiedService
     */
    'version': string;
    /**
     * The (optional) alias of the name to be used in the pipeline
     * @type {string}
     * @memberof FullyQualifiedService
     */
    'as'?: string;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * A message describing the error
     * @type {string}
     * @memberof GenericError
     */
    'message': string;
    /**
     * A code describing the error (this is not an HTTP status code)
     * @type {number}
     * @memberof GenericError
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface Get200Response
 */
export interface Get200Response {
    /**
     * 
     * @type {DaemonStatus}
     * @memberof Get200Response
     */
    'status': DaemonStatus;
    /**
     * Error message of the daemon status
     * @type {string}
     * @memberof Get200Response
     */
    'error_message'?: string;
    /**
     * The version of the roverd daemon
     * @type {string}
     * @memberof Get200Response
     */
    'version': string;
    /**
     * The number of milliseconds the roverd daemon process has been running
     * @type {number}
     * @memberof Get200Response
     */
    'uptime': number;
    /**
     * The operating system of the rover
     * @type {string}
     * @memberof Get200Response
     */
    'os': string;
    /**
     * The system time of the rover as milliseconds since epoch
     * @type {number}
     * @memberof Get200Response
     */
    'systime': number;
    /**
     * The unique identifier of the rover
     * @type {number}
     * @memberof Get200Response
     */
    'rover_id'?: number;
    /**
     * The unique name of the rover
     * @type {string}
     * @memberof Get200Response
     */
    'rover_name'?: string;
    /**
     * 
     * @type {Get200ResponseMemory}
     * @memberof Get200Response
     */
    'memory': Get200ResponseMemory;
    /**
     * The CPU usage of the roverd process
     * @type {Array<Get200ResponseCpuInner>}
     * @memberof Get200Response
     */
    'cpu': Array<Get200ResponseCpuInner>;
}


/**
 * CPU usage information about a specific core
 * @export
 * @interface Get200ResponseCpuInner
 */
export interface Get200ResponseCpuInner {
    /**
     * The core number
     * @type {number}
     * @memberof Get200ResponseCpuInner
     */
    'core': number;
    /**
     * The total amount of CPU available on the core
     * @type {number}
     * @memberof Get200ResponseCpuInner
     */
    'total': number;
    /**
     * The amount of CPU used on the core
     * @type {number}
     * @memberof Get200ResponseCpuInner
     */
    'used': number;
}
/**
 * Memory usage information
 * @export
 * @interface Get200ResponseMemory
 */
export interface Get200ResponseMemory {
    /**
     * The total amount of memory available on the rover in megabytes
     * @type {number}
     * @memberof Get200ResponseMemory
     */
    'total': number;
    /**
     * The amount of memory used on the rover in megabytes
     * @type {number}
     * @memberof Get200ResponseMemory
     */
    'used': number;
}
/**
 * 
 * @export
 * @interface PipelineGet200Response
 */
export interface PipelineGet200Response {
    /**
     * 
     * @type {PipelineStatus}
     * @memberof PipelineGet200Response
     */
    'status': PipelineStatus;
    /**
     * Milliseconds since epoch when the pipeline was manually started
     * @type {number}
     * @memberof PipelineGet200Response
     */
    'last_start'?: number;
    /**
     * Milliseconds since epoch when the pipeline was manually stopped
     * @type {number}
     * @memberof PipelineGet200Response
     */
    'last_stop'?: number;
    /**
     * 
     * @type {PipelineGet200ResponseStoppingService}
     * @memberof PipelineGet200Response
     */
    'stopping_service'?: PipelineGet200ResponseStoppingService;
    /**
     * Milliseconds since epoch when the pipeline was automatically restarted (on process faults)
     * @type {number}
     * @memberof PipelineGet200Response
     */
    'last_restart'?: number;
    /**
     * The list of fully qualified services that are enabled in this pipeline. If the pipeline was started, this includes a process for each service
     * @type {Array<PipelineGet200ResponseEnabledInner>}
     * @memberof PipelineGet200Response
     */
    'enabled': Array<PipelineGet200ResponseEnabledInner>;
}


/**
 * 
 * @export
 * @interface PipelineGet200ResponseEnabledInner
 */
export interface PipelineGet200ResponseEnabledInner {
    /**
     * 
     * @type {PipelineGet200ResponseEnabledInnerService}
     * @memberof PipelineGet200ResponseEnabledInner
     */
    'service': PipelineGet200ResponseEnabledInnerService;
    /**
     * 
     * @type {PipelineGet200ResponseEnabledInnerProcess}
     * @memberof PipelineGet200ResponseEnabledInner
     */
    'process'?: PipelineGet200ResponseEnabledInnerProcess;
}
/**
 * The last process that was started for this service (instantiated from the service). This can be undefined if the pipeline was not started before.
 * @export
 * @interface PipelineGet200ResponseEnabledInnerProcess
 */
export interface PipelineGet200ResponseEnabledInnerProcess {
    /**
     * The process ID. Depending on the status, this PID might not exist anymore
     * @type {number}
     * @memberof PipelineGet200ResponseEnabledInnerProcess
     */
    'pid': number;
    /**
     * 
     * @type {ProcessStatus}
     * @memberof PipelineGet200ResponseEnabledInnerProcess
     */
    'status': ProcessStatus;
    /**
     * The number of milliseconds the process has been running
     * @type {number}
     * @memberof PipelineGet200ResponseEnabledInnerProcess
     */
    'uptime': number;
    /**
     * The amount of memory used by the process in megabytes
     * @type {number}
     * @memberof PipelineGet200ResponseEnabledInnerProcess
     */
    'memory': number;
    /**
     * The percentage of CPU used by the process
     * @type {number}
     * @memberof PipelineGet200ResponseEnabledInnerProcess
     */
    'cpu': number;
}


/**
 * The fully qualified service that is enabled
 * @export
 * @interface PipelineGet200ResponseEnabledInnerService
 */
export interface PipelineGet200ResponseEnabledInnerService {
    /**
     * 
     * @type {FullyQualifiedService}
     * @memberof PipelineGet200ResponseEnabledInnerService
     */
    'fq': FullyQualifiedService;
    /**
     * The number of faults that have occurred (causing the pipeline to restart) since pipeline.last_start
     * @type {number}
     * @memberof PipelineGet200ResponseEnabledInnerService
     */
    'faults': number;
    /**
     * The most recent exit code returned by the process.
     * @type {number}
     * @memberof PipelineGet200ResponseEnabledInnerService
     */
    'exit': number;
}
/**
 * The service that caused the pipeline to stop
 * @export
 * @interface PipelineGet200ResponseStoppingService
 */
export interface PipelineGet200ResponseStoppingService {
    /**
     * 
     * @type {FullyQualifiedService}
     * @memberof PipelineGet200ResponseStoppingService
     */
    'fq'?: FullyQualifiedService;
}
/**
 * 
 * @export
 * @interface PipelinePostRequestInner
 */
export interface PipelinePostRequestInner {
    /**
     * 
     * @type {FullyQualifiedService}
     * @memberof PipelinePostRequestInner
     */
    'fq': FullyQualifiedService;
}
/**
 * 
 * @export
 * @interface PipelineSetError
 */
export interface PipelineSetError {
    /**
     * 
     * @type {PipelineSetErrorValidationErrors}
     * @memberof PipelineSetError
     */
    'validation_errors': PipelineSetErrorValidationErrors;
}
/**
 * The validation errors that prevent the pipeline from being set
 * @export
 * @interface PipelineSetErrorValidationErrors
 */
export interface PipelineSetErrorValidationErrors {
    /**
     * 
     * @type {Array<UnmetStreamError>}
     * @memberof PipelineSetErrorValidationErrors
     */
    'unmet_streams': Array<UnmetStreamError>;
    /**
     * 
     * @type {Array<UnmetServiceError>}
     * @memberof PipelineSetErrorValidationErrors
     */
    'unmet_services': Array<UnmetServiceError>;
    /**
     * List of duplicate services
     * @type {Array<string>}
     * @memberof PipelineSetErrorValidationErrors
     */
    'duplicate_services': Array<string>;
    /**
     * List of duplicate aliases
     * @type {Array<string>}
     * @memberof PipelineSetErrorValidationErrors
     */
    'duplicate_aliases': Array<string>;
    /**
     * List of aliases that are already used as a name of another service
     * @type {Array<string>}
     * @memberof PipelineSetErrorValidationErrors
     */
    'aliases_in_use': Array<string>;
}
/**
 * The status of the entire pipeline corresponding to a state machine
 * @export
 * @enum {string}
 */

export const PipelineStatus = {
    Empty: 'empty',
    Startable: 'startable',
    Started: 'started'
} as const;

export type PipelineStatus = typeof PipelineStatus[keyof typeof PipelineStatus];


/**
 * The status of a process in the pipeline
 * @export
 * @enum {string}
 */

export const ProcessStatus = {
    Running: 'running',
    Stopped: 'stopped',
    Terminated: 'terminated',
    Killed: 'killed'
} as const;

export type ProcessStatus = typeof ProcessStatus[keyof typeof ProcessStatus];


/**
 * 
 * @export
 * @interface ReferencedService
 */
export interface ReferencedService {
    /**
     * Fully qualified download url.
     * @type {string}
     * @memberof ReferencedService
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RoverdError
 */
export interface RoverdError {
    /**
     * Type of error
     * @type {string}
     * @memberof RoverdError
     */
    'errorType': RoverdErrorErrorTypeEnum;
    /**
     * 
     * @type {RoverdErrorErrorValue}
     * @memberof RoverdError
     */
    'errorValue': RoverdErrorErrorValue;
}

export const RoverdErrorErrorTypeEnum = {
    Generic: 'generic',
    Build: 'build',
    PipelineSet: 'pipeline_set'
} as const;

export type RoverdErrorErrorTypeEnum = typeof RoverdErrorErrorTypeEnum[keyof typeof RoverdErrorErrorTypeEnum];

/**
 * @type RoverdErrorErrorValue
 * @export
 */
export type RoverdErrorErrorValue = BuildError | GenericError | PipelineSetError;

/**
 * The status of any given service is either enabled or disabled
 * @export
 * @enum {string}
 */

export const ServiceStatus = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type ServiceStatus = typeof ServiceStatus[keyof typeof ServiceStatus];


/**
 * 
 * @export
 * @interface ServicesAuthorServiceVersionConfigurationPostRequestInner
 */
export interface ServicesAuthorServiceVersionConfigurationPostRequestInner {
    /**
     * The unique key, corresponding to a configuration key in the service.yaml file
     * @type {string}
     * @memberof ServicesAuthorServiceVersionConfigurationPostRequestInner
     */
    'key': string;
    /**
     * 
     * @type {ServicesAuthorServiceVersionConfigurationPostRequestInnerValue}
     * @memberof ServicesAuthorServiceVersionConfigurationPostRequestInner
     */
    'value': ServicesAuthorServiceVersionConfigurationPostRequestInnerValue;
}
/**
 * @type ServicesAuthorServiceVersionConfigurationPostRequestInnerValue
 * The value that should be set for this key. Can be either a string or a number, but must match the type in the service.yaml file
 * @export
 */
export type ServicesAuthorServiceVersionConfigurationPostRequestInnerValue = number | string;

/**
 * 
 * @export
 * @interface ServicesAuthorServiceVersionDelete200Response
 */
export interface ServicesAuthorServiceVersionDelete200Response {
    /**
     * Whether the pipeline was invalidated by this service deletion
     * @type {boolean}
     * @memberof ServicesAuthorServiceVersionDelete200Response
     */
    'invalidated_pipeline': boolean;
}
/**
 * 
 * @export
 * @interface ServicesAuthorServiceVersionGet200Response
 */
export interface ServicesAuthorServiceVersionGet200Response {
    /**
     * The time this version was last built as milliseconds since epoch, not set if the service was never built
     * @type {number}
     * @memberof ServicesAuthorServiceVersionGet200Response
     */
    'built_at'?: number;
    /**
     * The dependencies/inputs of this service version
     * @type {Array<ServicesAuthorServiceVersionGet200ResponseInputsInner>}
     * @memberof ServicesAuthorServiceVersionGet200Response
     */
    'inputs': Array<ServicesAuthorServiceVersionGet200ResponseInputsInner>;
    /**
     * The output streams of this service version
     * @type {Array<string>}
     * @memberof ServicesAuthorServiceVersionGet200Response
     */
    'outputs': Array<string>;
    /**
     * All configuration values of this service version and their tunability
     * @type {Array<ServicesAuthorServiceVersionGet200ResponseConfigurationInner>}
     * @memberof ServicesAuthorServiceVersionGet200Response
     */
    'configuration': Array<ServicesAuthorServiceVersionGet200ResponseConfigurationInner>;
}
/**
 * 
 * @export
 * @interface ServicesAuthorServiceVersionGet200ResponseConfigurationInner
 */
export interface ServicesAuthorServiceVersionGet200ResponseConfigurationInner {
    /**
     * The name of the configuration value
     * @type {string}
     * @memberof ServicesAuthorServiceVersionGet200ResponseConfigurationInner
     */
    'name': string;
    /**
     * The type of the configuration value
     * @type {string}
     * @memberof ServicesAuthorServiceVersionGet200ResponseConfigurationInner
     */
    'type': ServicesAuthorServiceVersionGet200ResponseConfigurationInnerTypeEnum;
    /**
     * 
     * @type {ServicesAuthorServiceVersionGet200ResponseConfigurationInnerValue}
     * @memberof ServicesAuthorServiceVersionGet200ResponseConfigurationInner
     */
    'value': ServicesAuthorServiceVersionGet200ResponseConfigurationInnerValue;
    /**
     * Whether this configuration value is tunable
     * @type {boolean}
     * @memberof ServicesAuthorServiceVersionGet200ResponseConfigurationInner
     */
    'tunable': boolean;
}

export const ServicesAuthorServiceVersionGet200ResponseConfigurationInnerTypeEnum = {
    String: 'string',
    Number: 'number'
} as const;

export type ServicesAuthorServiceVersionGet200ResponseConfigurationInnerTypeEnum = typeof ServicesAuthorServiceVersionGet200ResponseConfigurationInnerTypeEnum[keyof typeof ServicesAuthorServiceVersionGet200ResponseConfigurationInnerTypeEnum];

/**
 * @type ServicesAuthorServiceVersionGet200ResponseConfigurationInnerValue
 * The value of the configuration
 * @export
 */
export type ServicesAuthorServiceVersionGet200ResponseConfigurationInnerValue = number | string;

/**
 * 
 * @export
 * @interface ServicesAuthorServiceVersionGet200ResponseInputsInner
 */
export interface ServicesAuthorServiceVersionGet200ResponseInputsInner {
    /**
     * The name of the service dependency
     * @type {string}
     * @memberof ServicesAuthorServiceVersionGet200ResponseInputsInner
     */
    'service': string;
    /**
     * The streams of the service dependency
     * @type {Array<string>}
     * @memberof ServicesAuthorServiceVersionGet200ResponseInputsInner
     */
    'streams': Array<string>;
}
/**
 * UnmetServiceError
 * @export
 * @interface UnmetServiceError
 */
export interface UnmetServiceError {
    /**
     * 
     * @type {string}
     * @memberof UnmetServiceError
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof UnmetServiceError
     */
    'target': string;
}
/**
 * UnmetStreamError
 * @export
 * @interface UnmetStreamError
 */
export interface UnmetStreamError {
    /**
     * 
     * @type {string}
     * @memberof UnmetStreamError
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof UnmetStreamError
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof UnmetStreamError
     */
    'stream': string;
}
/**
 * 
 * @export
 * @interface UpdatePostRequest
 */
export interface UpdatePostRequest {
    /**
     * The roverd version to update to
     * @type {string}
     * @memberof UpdatePostRequest
     */
    'version': string;
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stops any running pipeline and emergency stops the rover.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emergencyPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/emergency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the health and versioning information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Shutdown the rover.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the health and versioning information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Self-update the roverd daemon process
         * @param {UpdatePostRequest} updatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost: async (updatePostRequest: UpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePostRequest' is not null or undefined
            assertParamExists('updatePost', 'updatePostRequest', updatePostRequest)
            const localVarPath = `/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Stops any running pipeline and emergency stops the rover.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emergencyPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emergencyPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.emergencyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the health and versioning information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Shutdown the rover.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdownPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shutdownPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.shutdownPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the health and versioning information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Self-update the roverd daemon process
         * @param {UpdatePostRequest} updatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePost(updatePostRequest: UpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(updatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.updatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Stops any running pipeline and emergency stops the rover.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emergencyPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.emergencyPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the health and versioning information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<Get200Response> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Shutdown the rover.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.shutdownPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the health and versioning information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<Get200Response> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Self-update the roverd daemon process
         * @param {UpdatePostRequest} updatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost(updatePostRequest: UpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePost(updatePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Stops any running pipeline and emergency stops the rover.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public emergencyPost(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).emergencyPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the health and versioning information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Shutdown the rover.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public shutdownPost(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).shutdownPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the health and versioning information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Self-update the roverd daemon process
     * @param {UpdatePostRequest} updatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public updatePost(updatePostRequest: UpdatePostRequest, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).updatePost(updatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelineApi - axios parameter creator
 * @export
 */
export const PipelineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve logs for any service. Logs from running or previously run services can be viewed and will be kept until rover reboot.
         * @param {string} author The author of the service.
         * @param {string} name The name of the service.
         * @param {string} version The version of the service.
         * @param {number} [lines] The number of log lines to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsAuthorNameVersionGet: async (author: string, name: string, version: string, lines?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('logsAuthorNameVersionGet', 'author', author)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('logsAuthorNameVersionGet', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('logsAuthorNameVersionGet', 'version', version)
            const localVarPath = `/logs/{author}/{name}/{version}`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (lines !== undefined) {
                localVarQueryParameter['lines'] = lines;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve pipeline status and process execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the services that are enabled in this pipeline, by specifying the fully qualified services
         * @param {Array<PipelinePostRequestInner>} pipelinePostRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinePost: async (pipelinePostRequestInner: Array<PipelinePostRequestInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelinePostRequestInner' is not null or undefined
            assertParamExists('pipelinePost', 'pipelinePostRequestInner', pipelinePostRequestInner)
            const localVarPath = `/pipeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelinePostRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStartPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStopPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelineApi - functional programming interface
 * @export
 */
export const PipelineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve logs for any service. Logs from running or previously run services can be viewed and will be kept until rover reboot.
         * @param {string} author The author of the service.
         * @param {string} name The name of the service.
         * @param {string} version The version of the service.
         * @param {number} [lines] The number of log lines to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsAuthorNameVersionGet(author: string, name: string, version: string, lines?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsAuthorNameVersionGet(author, name, version, lines, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineApi.logsAuthorNameVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve pipeline status and process execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineApi.pipelineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the services that are enabled in this pipeline, by specifying the fully qualified services
         * @param {Array<PipelinePostRequestInner>} pipelinePostRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinePost(pipelinePostRequestInner: Array<PipelinePostRequestInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinePost(pipelinePostRequestInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineApi.pipelinePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStartPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStartPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineApi.pipelineStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStopPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStopPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineApi.pipelineStopPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelineApi - factory interface
 * @export
 */
export const PipelineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelineApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve logs for any service. Logs from running or previously run services can be viewed and will be kept until rover reboot.
         * @param {string} author The author of the service.
         * @param {string} name The name of the service.
         * @param {string} version The version of the service.
         * @param {number} [lines] The number of log lines to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsAuthorNameVersionGet(author: string, name: string, version: string, lines?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.logsAuthorNameVersionGet(author, name, version, lines, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve pipeline status and process execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineGet(options?: RawAxiosRequestConfig): AxiosPromise<PipelineGet200Response> {
            return localVarFp.pipelineGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the services that are enabled in this pipeline, by specifying the fully qualified services
         * @param {Array<PipelinePostRequestInner>} pipelinePostRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinePost(pipelinePostRequestInner: Array<PipelinePostRequestInner>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelinePost(pipelinePostRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStartPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineStartPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStopPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineStopPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelineApi - object-oriented interface
 * @export
 * @class PipelineApi
 * @extends {BaseAPI}
 */
export class PipelineApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve logs for any service. Logs from running or previously run services can be viewed and will be kept until rover reboot.
     * @param {string} author The author of the service.
     * @param {string} name The name of the service.
     * @param {string} version The version of the service.
     * @param {number} [lines] The number of log lines to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public logsAuthorNameVersionGet(author: string, name: string, version: string, lines?: number, options?: RawAxiosRequestConfig) {
        return PipelineApiFp(this.configuration).logsAuthorNameVersionGet(author, name, version, lines, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve pipeline status and process execution information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public pipelineGet(options?: RawAxiosRequestConfig) {
        return PipelineApiFp(this.configuration).pipelineGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the services that are enabled in this pipeline, by specifying the fully qualified services
     * @param {Array<PipelinePostRequestInner>} pipelinePostRequestInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public pipelinePost(pipelinePostRequestInner: Array<PipelinePostRequestInner>, options?: RawAxiosRequestConfig) {
        return PipelineApiFp(this.configuration).pipelinePost(pipelinePostRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public pipelineStartPost(options?: RawAxiosRequestConfig) {
        return PipelineApiFp(this.configuration).pipelineStartPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public pipelineStopPost(options?: RawAxiosRequestConfig) {
        return PipelineApiFp(this.configuration).pipelineStopPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetches the zip file from the given URL and installs the service onto the filesystem
         * @param {FetchPostRequest} fetchPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPost: async (fetchPostRequest: FetchPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fetchPostRequest' is not null or undefined
            assertParamExists('fetchPost', 'fetchPostRequest', fetchPostRequest)
            const localVarPath = `/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetchPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of all fully qualified services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fqnsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fqns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of parsable services for a specific author
         * @param {string} author The author name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorGet: async (author: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('servicesAuthorGet', 'author', author)
            const localVarPath = `/services/{author}`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of parsable service versions for a specific author and service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceGet: async (author: string, service: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('servicesAuthorServiceGet', 'author', author)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('servicesAuthorServiceGet', 'service', service)
            const localVarPath = `/services/{author}/{service}`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update service.yaml configuration values of a fully qualified service in-place
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>} servicesAuthorServiceVersionConfigurationPostRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionConfigurationPost: async (author: string, service: string, version: string, servicesAuthorServiceVersionConfigurationPostRequestInner: Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionConfigurationPost', 'author', author)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionConfigurationPost', 'service', service)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionConfigurationPost', 'version', version)
            // verify required parameter 'servicesAuthorServiceVersionConfigurationPostRequestInner' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionConfigurationPost', 'servicesAuthorServiceVersionConfigurationPostRequestInner', servicesAuthorServiceVersionConfigurationPostRequestInner)
            const localVarPath = `/services/{author}/{service}/{version}/configuration`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesAuthorServiceVersionConfigurationPostRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific version of a service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionDelete: async (author: string, service: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionDelete', 'author', author)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionDelete', 'service', service)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionDelete', 'version', version)
            const localVarPath = `/services/{author}/{service}/{version}`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the status of a specific version of a service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionGet: async (author: string, service: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionGet', 'author', author)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionGet', 'service', service)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionGet', 'version', version)
            const localVarPath = `/services/{author}/{service}/{version}`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build a fully qualified service version
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionPost: async (author: string, service: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'author' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionPost', 'author', author)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionPost', 'service', service)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('servicesAuthorServiceVersionPost', 'version', version)
            const localVarPath = `/services/{author}/{service}/{version}`
                .replace(`{${"author"}}`, encodeURIComponent(String(author)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of all authors that have parsable services. With these authors you can query further for services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a new service or new version to the rover by uploading a ZIP file
         * @param {File} [content] The content of the ZIP file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPost: async (content?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (content !== undefined) { 
                localVarFormParams.append('content', content as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetches the zip file from the given URL and installs the service onto the filesystem
         * @param {FetchPostRequest} fetchPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPost(fetchPostRequest: FetchPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPost(fetchPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.fetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a list of all fully qualified services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fqnsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FullyQualifiedService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fqnsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.fqnsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of parsable services for a specific author
         * @param {string} author The author name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAuthorGet(author: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAuthorGet(author, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesAuthorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of parsable service versions for a specific author and service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAuthorServiceGet(author: string, service: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAuthorServiceGet(author, service, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesAuthorServiceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update service.yaml configuration values of a fully qualified service in-place
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>} servicesAuthorServiceVersionConfigurationPostRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAuthorServiceVersionConfigurationPost(author: string, service: string, version: string, servicesAuthorServiceVersionConfigurationPostRequestInner: Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAuthorServiceVersionConfigurationPost(author, service, version, servicesAuthorServiceVersionConfigurationPostRequestInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesAuthorServiceVersionConfigurationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific version of a service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAuthorServiceVersionDelete(author: string, service: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicesAuthorServiceVersionDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAuthorServiceVersionDelete(author, service, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesAuthorServiceVersionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the status of a specific version of a service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAuthorServiceVersionGet(author: string, service: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicesAuthorServiceVersionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAuthorServiceVersionGet(author, service, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesAuthorServiceVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Build a fully qualified service version
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAuthorServiceVersionPost(author: string, service: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAuthorServiceVersionPost(author, service, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesAuthorServiceVersionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of all authors that have parsable services. With these authors you can query further for services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.servicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a new service or new version to the rover by uploading a ZIP file
         * @param {File} [content] The content of the ZIP file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPost(content?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPost(content, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.uploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetches the zip file from the given URL and installs the service onto the filesystem
         * @param {FetchPostRequest} fetchPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPost(fetchPostRequest: FetchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<FetchPost200Response> {
            return localVarFp.fetchPost(fetchPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of all fully qualified services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fqnsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<FullyQualifiedService>> {
            return localVarFp.fqnsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of parsable services for a specific author
         * @param {string} author The author name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorGet(author: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.servicesAuthorGet(author, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of parsable service versions for a specific author and service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceGet(author: string, service: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.servicesAuthorServiceGet(author, service, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update service.yaml configuration values of a fully qualified service in-place
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>} servicesAuthorServiceVersionConfigurationPostRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionConfigurationPost(author: string, service: string, version: string, servicesAuthorServiceVersionConfigurationPostRequestInner: Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesAuthorServiceVersionConfigurationPost(author, service, version, servicesAuthorServiceVersionConfigurationPostRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific version of a service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionDelete(author: string, service: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<ServicesAuthorServiceVersionDelete200Response> {
            return localVarFp.servicesAuthorServiceVersionDelete(author, service, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the status of a specific version of a service
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionGet(author: string, service: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<ServicesAuthorServiceVersionGet200Response> {
            return localVarFp.servicesAuthorServiceVersionGet(author, service, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build a fully qualified service version
         * @param {string} author The author name
         * @param {string} service The service name
         * @param {string} version The version of the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAuthorServiceVersionPost(author: string, service: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesAuthorServiceVersionPost(author, service, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of all authors that have parsable services. With these authors you can query further for services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.servicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a new service or new version to the rover by uploading a ZIP file
         * @param {File} [content] The content of the ZIP file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPost(content?: File, options?: RawAxiosRequestConfig): AxiosPromise<FetchPost200Response> {
            return localVarFp.uploadPost(content, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Fetches the zip file from the given URL and installs the service onto the filesystem
     * @param {FetchPostRequest} fetchPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public fetchPost(fetchPostRequest: FetchPostRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).fetchPost(fetchPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of all fully qualified services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public fqnsGet(options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).fqnsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of parsable services for a specific author
     * @param {string} author The author name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesAuthorGet(author: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesAuthorGet(author, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of parsable service versions for a specific author and service
     * @param {string} author The author name
     * @param {string} service The service name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesAuthorServiceGet(author: string, service: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesAuthorServiceGet(author, service, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update service.yaml configuration values of a fully qualified service in-place
     * @param {string} author The author name
     * @param {string} service The service name
     * @param {string} version The version of the service
     * @param {Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>} servicesAuthorServiceVersionConfigurationPostRequestInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesAuthorServiceVersionConfigurationPost(author: string, service: string, version: string, servicesAuthorServiceVersionConfigurationPostRequestInner: Array<ServicesAuthorServiceVersionConfigurationPostRequestInner>, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesAuthorServiceVersionConfigurationPost(author, service, version, servicesAuthorServiceVersionConfigurationPostRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific version of a service
     * @param {string} author The author name
     * @param {string} service The service name
     * @param {string} version The version of the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesAuthorServiceVersionDelete(author: string, service: string, version: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesAuthorServiceVersionDelete(author, service, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the status of a specific version of a service
     * @param {string} author The author name
     * @param {string} service The service name
     * @param {string} version The version of the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesAuthorServiceVersionGet(author: string, service: string, version: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesAuthorServiceVersionGet(author, service, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build a fully qualified service version
     * @param {string} author The author name
     * @param {string} service The service name
     * @param {string} version The version of the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesAuthorServiceVersionPost(author: string, service: string, version: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesAuthorServiceVersionPost(author, service, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of all authors that have parsable services. With these authors you can query further for services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesGet(options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a new service or new version to the rover by uploading a ZIP file
     * @param {File} [content] The content of the ZIP file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public uploadPost(content?: File, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).uploadPost(content, options).then((request) => request(this.axios, this.basePath));
    }
}



